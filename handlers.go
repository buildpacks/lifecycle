package lifecycle

import (
	"github.com/BurntSushi/toml"
	"github.com/buildpacks/imgutil"
	"github.com/pkg/errors"

	"github.com/buildpacks/lifecycle/buildpack"
)

//go:generate mockgen -package testmock -destination testmock/cache_handler.go github.com/buildpacks/lifecycle CacheHandler
type CacheHandler interface {
	InitCache(imageRef, dir string) (Cache, error)
}

//go:generate mockgen -package testmock -destination testmock/image_handler.go github.com/buildpacks/lifecycle ImageHandler
type ImageHandler interface {
	InitImage(imageRef string) (imgutil.Image, error)
	Docker() bool
}

//go:generate mockgen -package testmock -destination testmock/registry_handler.go github.com/buildpacks/lifecycle RegistryHandler
type RegistryHandler interface {
	EnsureReadAccess(imageRefs ...string) error
	EnsureWriteAccess(imageRefs ...string) error
}

//go:generate mockgen -package testmock -destination testmock/api_verifier.go github.com/buildpacks/lifecycle APIVerifier
// APIVerifier exists to avoid having the lifecycle package depend on the cmd package.
// The package dependency actually already exists, but this is to avoid making it worse.
// Eventually, much logic in the cmd package should move to the platform package, after which
// we might be able to remove this interface.
type APIVerifier interface {
	VerifyBuildpackAPIForBuildpack(name, requested string) error
	VerifyBuildpackAPIForExtension(name, requested string) error
}

//go:generate mockgen -package testmock -destination testmock/config_handler.go github.com/buildpacks/lifecycle ConfigHandler
type ConfigHandler interface {
	ReadGroup(path string) ([]buildpack.GroupElement, error)
	ReadOrder(path string) (buildpack.Order, buildpack.Order, error)
}

type DefaultConfigHandler struct {
	apiVerifier APIVerifier
}

func NewConfigHandler(apiVerifier APIVerifier) *DefaultConfigHandler {
	return &DefaultConfigHandler{apiVerifier: apiVerifier}
}

func (h *DefaultConfigHandler) ReadGroup(path string) ([]buildpack.GroupElement, error) {
	group, err := ReadGroup(path)
	if err != nil {
		return nil, errors.Wrap(err, "reading buildpack group")
	}
	if err = h.verifyBuildpackApis(group); err != nil {
		return nil, err
	}
	return group.Group, nil
}

func ReadGroup(path string) (buildpack.Group, error) {
	var group buildpack.Group
	_, err := toml.DecodeFile(path, &group)
	return group, err
}

func (h *DefaultConfigHandler) verifyBuildpackApis(group buildpack.Group) error {
	for _, groupEl := range group.Group {
		if groupEl.API == "" {
			// if this group was generated by this lifecycle, API should be set
			// but if for some reason it isn't default to 0.2
			groupEl.API = "0.2"
		}
		switch {
		case groupEl.Extension:
			if err := h.apiVerifier.VerifyBuildpackAPIForExtension(groupEl.String(), groupEl.API); err != nil {
				return err
			}
		default:
			if err := h.apiVerifier.VerifyBuildpackAPIForBuildpack(groupEl.String(), groupEl.API); err != nil {
				return err
			}
		}
	}
	return nil
}

func (h *DefaultConfigHandler) ReadOrder(path string) (buildpack.Order, buildpack.Order, error) {
	return ReadOrder(path)
}

func ReadOrder(path string) (buildpack.Order, buildpack.Order, error) {
	var order struct {
		Order    buildpack.Order `toml:"order"`
		OrderExt buildpack.Order `toml:"order-ext"`
	}
	_, err := toml.DecodeFile(path, &order)
	return order.Order, order.OrderExt, err
}
